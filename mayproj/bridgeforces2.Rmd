---
title: "Forces on a bridge -- Fast version"
author: "Simon Hickinbotham"
date: "29/03/2021"
output:
  html_document: default
  ioslides_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Summary

- The plan is to use evolution to search over a devo rule space to find good devo patterns
- We are trying to get to the point where we have some physical properties of a shape so we can use this to influence development
- I've ported the openconstructor physics engine to C++ so it runs fast enough to do this
- Next step is to feed the physics info back to influence the (developing) structure - options discussed below



```{Rcpp importsoda, code=xfun::read_utf8('sodaphysics.cpp'), include=FALSE}
//This chunk imports the Rcpp code
```

# Current status - growth

We've got the 'virtual growth' part of the system working pretty well. There are some issues we'll have to return to for the final system: 

- The link between 'foundations' and 'stimuli' is currently quite crude - the current system only works because the stimulus is equidistant from *both* foundations. We'll need to fix this once the whole evodevo process is established. 
- There's a bit of a hack in the example - the inner nodes at the base of the bridge get converted to foundation points manually



```{r makebridge, echo=FALSE, message=FALSE, animation.hook="gifski", cache=T, interval=0.2}
source("maycode.R")

nxl <- c(0,500)
net <- makehexnet(xlim=nxl)
net <- setnodetype(net,50,-5,100,5)
net <- setnodetype(net,410,-5,460,5)
##


inhib=data.frame(x0=190,y0=-10,x1=310,y1=150)

#net <- setnodetype(net,inhib$x0,inhib$y0,inhib$x1,inhib$y1,"X")
net <- setnodetype(net,x0=inhib$x0,y0=inhib$y0,x1=inhib$x1,y1=inhib$y1,"X")

xnet <- net

stim <- data.frame(x=250,y=175)

#plotnet(xnet,stim,inhib,xlim = nxl)

nl <- list()
nl[[1]]<-net

#nl = rungrowth(nl, stim = stim,inhib=inhib, nsteps = 5,xlim=nxl,ylim=c(0,200))

saveRDS(nl,file="ntest1.RDS")



net <- xnet
sf <- 100 # scale factor

net$n$x = net$n$x/sf
net$n$y = net$n$y/sf

sinhib <- inhib/sf

sstim <- stim/sf

#plotnet(net,sstim,sinhib,xlim = range(net$n$x),ylim=range(net$n$y))

nl <- list()
nl[[1]]<-net

nl = rungrowth(nl, stim = sstim,inhib=sinhib,odist=0.2, nsteps = 25,xlim=range(net$n$x),ylim=range(net$n$y))

source("sodaphysics.R")
subnet <- nl[[length(nl)]]
net<- nl[[length(nl)]]


subnet <- setnodetype(subnet,0.5,-.05,1.1,0.05)
subnet <- setnodetype(subnet,3.9,-0.05,4.6,0.05)
#for(ff in 1:1)
#plotnet(subnet,sstim,sinhib,xlim = range(net$n$x),ylim=range(net$n$y))


subnet$n = subnet$n[subnet$n$type=="S" | subnet$n$type=="F" ,]
subnet$e = NULL
sei = 1
for(ee in 1:nrow(net$e)){
  if(net$e$from[ee] %in% subnet$n$n & net$e$to[ee] %in% subnet$n$n){
    if(sei == 1)
      subnet$e <- net$e[ee,]
    else
      subnet$e = rbind(subnet$e, net$e[ee,])
    sei = sei + 1
  }
}
```



# Current status - physics

I'm now looking at how to use the forces generated by the physics engine to influence the growth. Take a look at this plot: 


```{r ch, echo=FALSE, fig.height=10, fig.width=12, message=FALSE, animation.hook="gifski", cache=T, interval=0.0125}
source("sodaphysics.R")
ff <- 0.137
#kk <- 6.25
dt <-  0.001666667
ni <- 300

restlength <- VECTOR.len(subnet$n,subnet$e$from[1],subnet$e$to[1])

par(mfrow=c(2  ,2))

saveRDS(subnet,"tmp.RDS")
gn <- readRDS("tmp.RDS")

gn$n$fx <- 0
gn$n$fy <- 0
gn$n$vx <- 0
gn$n$vy <- 0
gn$n$ax <- 0
gn$n$ay <- 0
gn$e$fMag <- 0

saveRDS(gn,"tmp.RDS")
gn2<-readRDS("tmp.RDS")
#gn2<-copy(gn)

kk<-6.25
tinc <-   60
ntimes <- 250
mm<-1.0

#for(tt in seq(1,20,1)){

fot <- list()
maxfx = rep(0,ntimes)
minfx = rep(0,ntimes)
maxfy = rep(0,ntimes)
minfy = rep(0,ntimes)


maxmn = rep(0,ntimes)
minmn = rep(0,ntimes)
maxme = rep(0,ntimes)
minme = rep(0,ntimes)
  

for(tt in 1:ntimes){
  rcupdateModel(gn$n,gn$e,restlength,ff,kk,dt,tinc,mm,1)
  #gn2 <- updateModel(gn2,ff,kk,dt,300)
  
  if(tt==1)
    gn1 <- gn

  plotnet(gn,xlim = range(net$n$x),ylim=range(net$n$y))
  plotForces(gn)
  gn$n$fmag <- sqrt((gn$n$fx*gn$n$fx)+(gn$n$fy*gn$n$fy))
  mfh <- gn$n[gn$n$x < 2.51,]
  mfn <- mfh[mfh$fmag == max(mfh$fmag),]
  points(x=mfn$x[1],y=mfn$y[1],cex = 2,pch=19,col="green")
  mfn <- mfh[mfh$fmag == min(mfh$fmag),]
  points(x=mfn$x[1],y=mfn$y[1],cex = 2,pch=17,col="green")
  #mfn <- gn$n[gn$n$fy == max(gn$n$fy),]
  #points(x=mfn$x[1],y=mfn$y[1],cex = 2,pch=19,col="pink")
  #mfn <- gn$n[gn$n$fy == min(gn$n$fy),]
  #points(x=mfn$x[1],y=mfn$y[1],cex = 2,pch=17,col="pink")
  
  title(sprintf("moving nodes: tt = %02d",tt))
  
  rcupdateModel(gn2$n,gn2$e,restlength,ff,kk,dt,tinc,mm,0)
  #gn2 <- updateModel(gn2,ff,kk,dt,tinc)

  
  
  
  
  
  
  #plotnet(gn2,xlim = range(net$n$x),ylim=range(net$n$y))
  #plotForceMap(gn2$n,gn$e)
  #title(sprintf("fixed nodes: tt = %02d",tt))
  
  plot(NA,xlim = c(0,5),ylim=c(-0.5,2.5),asp=T)
  
  for(nn in 1:nrow(gn$n)){
    x1 <- gn1$n$x[nn] + (10*gn$n$fx[nn])
    y1 <- gn1$n$y[nn] + (10*gn$n$fy[nn])
    segments(x0=gn1$n$x[nn],y0=gn1$n$y[nn],x1=x1,y1=y1,lwd=4)
    
    x1 <- gn1$n$x[nn] + (10*gn$n$vx[nn])
    y1 <- gn1$n$y[nn] + (10*gn$n$vy[nn])
    segments(x0=gn1$n$x[nn],y0=gn1$n$y[nn],x1=x1,y1=y1,col="red")
    
    x1 <- gn1$n$x[nn] + (10*gn$n$ax[nn])
    y1 <- gn1$n$y[nn] + (10*gn$n$ay[nn])
    segments(x0=gn1$n$x[nn],y0=gn1$n$y[nn],x1=x1,y1=y1,col="green")
    
    
  }
  
  
  
  
  
  
  
  
  #Use this for later analysis
  fot[[tt]]<- data.frame(x=gn$n$x,y=gn$n$y,fx=gn$n$fx,fy=gn$n$fy)
  
  #maxfx[tt] <- max(gn$n$fx)
  #maxfy[tt] <- max(gn$n$fy)
  #minfx[tt] <- min(gn$n$fx)
  #minfy[tt] <- min(gn$n$fy)
  
  #plot(x=1:tt,y=maxfx[1:tt],xlim=c(1,ntimes),ylim=c(-0.4,0.4),type="l",main="forces in x",xlab="time",ylab="force in x")
  #points(x=rep(tt,nrow(gn$n)),y=gn$n$fx,pch=20,cex=0.5,col="red")
  #lines(x=1:tt,y=minfx[1:tt])
  
  #plot(x=1:tt,y=maxfy[1:tt],xlim=c(1,ntimes),ylim=c(-0.4,0.4),type="l",main="forces in y")
  #points(x=rep(tt,nrow(gn$n)),y=gn$n$fy,pch=20,cex=0.5,col="red")
  #lines(x=1:tt,y=minfy[1:tt])
  
  #########
  # Fmag on nodes and edges
  maxmn[tt] <- max(gn$n$fmag)
  minmn[tt] <- min(gn$n$fmag)
  maxme[tt] <- max(gn$e$fMag)
  minme[tt] <- min(gn$e$fMag)
  plot(x=1:tt,y=maxmn[1:tt],xlim=c(1,ntimes),ylim=c(-0.1,0.7),type="l",main="fmag on nodes",xlab="time",ylab="force in x")
  points(x=rep(tt,nrow(gn$n)),y=gn$n$fmag,pch=20,cex=0.5,col="red")
  lines(x=1:tt,y=minmn[1:tt])
  
  
  plot(x=1:tt,y=maxme[1:tt],xlim=c(1,ntimes),ylim=c(-0.6,0.6),type="l",main="fmag on edges",xlab="time",ylab="force in x")
  points(x=rep(tt,nrow(gn$e)),y=gn$e$fMag,pch=20,cex=0.5,col="red")
  lines(x=1:tt,y=minme[1:tt])
  
}
#}
```

- top left plot is the 'full' physics if we run the system for a total of 5000 iterations. The green circle is the node with the maximum 
force and the green triangle is the node with minimum force. The max force point is always a
- top right is the forces applied to the "static" frame - not much to see unless you run for many more iterations - but it does help the eye to spot how the stresses change over time
- bottem left shows the max and min forces in the x direction - red dots show the distribution of forces at time t
- bottom right shows the same for the y direction

## Issues to resolve: 

- Forces are calculated using Euler's method, which is robust: iterate through tiny time increments and update the position, force vectors and resulting acceleration each step. The question is, how long should we run the physics to evaluate the forces? Should this parameter be part of the EA? 
- Currently forces are only calculated once the network has completed a 'solid' link between Foundatons and stimuli - is that the correct approach?
- I think the main thing to look at is the FMag at each node - perhaps set a simple threshold? 


# Options for updating the development based on forces: 

There are several ways we can use this information to influence how the shape develops. Here are the options in increasing level of perceived difficulty: 

- **change the size of the edges** - The basic idea is that if a force is large, a strut thickness should be increased, and if small it should be reduced. 
- **change the position of the nodes** - Since the overall force is a vector with a direction, we should consider how to move nodes such that these vectors are reduced. 
- **switch nodes 'on' or 'off'** 
- **add or remove nodes**



The issue is how to do this *dynamically* and still get the thing to converge instead of 

Perhaps the thing to do is to focus on 1 individual node at a time and study it in depth - pick 

# Adjusting global parameters for stiffness

## manipulating `k` 




```{r kkcheck, echo=FALSE, fig.height=10, fig.width=12, message=FALSE, animation.hook="gifski", cache=F, interval=0.0125}
source("sodaphysics.R")
ff <- 0.137
#kk <- 6.25
dt <-  0.001666667
ni <- 300

restlength <- VECTOR.len(subnet$n,subnet$e$from[1],subnet$e$to[1])

par(mfrow=c(2  ,2))

saveRDS(subnet,"tmp.RDS")
gn <- readRDS("tmp.RDS")

gn$n$fx <- 0
gn$n$fy <- 0
gn$n$vx <- 0
gn$n$vy <- 0
gn$n$ax <- 0
gn$n$ay <- 0
gn$e$fMag <- 0

saveRDS(gn,"tmp.RDS")
gn0<-readRDS("tmp.RDS")
gn1<-readRDS("tmp.RDS")
gn2<-readRDS("tmp.RDS")
gn3<-readRDS("tmp.RDS")
#gn2<-copy(gn)

kk1<-6.25
kk0<-kk1/10
kk2<-kk1*10
kk3<-kk1*50


tinc <-   60
ntimes <- 450
mm<-1.0


for(tt in 1:ntimes){
  rcupdateModel(gn0$n,gn$e,restlength,ff,kk0,dt,tinc,mm,1)
  rcupdateModel(gn1$n,gn$e,restlength,ff,kk1,dt,tinc,mm,1)
  rcupdateModel(gn2$n,gn$e,restlength,ff,kk2,dt,tinc,mm,1)
  rcupdateModel(gn3$n,gn$e,restlength,ff,kk3,dt,tinc,mm,1)
  
  plotnet(gn0,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn0)
  title(sprintf("t  = %d\nk = %0.2f",tt,kk0))
  
  plotnet(gn1,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn1)
  title(sprintf("t  = %d\nk = %0.2f",tt,kk1))
  
  plotnet(gn2,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn2)
  title(sprintf("t  = %d\nk = %0.2f",tt,kk2))
  
  plotnet(gn3,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn3)
  title(sprintf("t  = %d\nk = %0.2f",tt,kk3))
  
}
```

kk is the 'springiness of the material and we can manipulate this quite easily. Unfortunately at large values of kk the simulation becomes unstable - because the model is so simple, small errors in the update get amplified. 


# Changing the mass

```{r mmcheck, echo=FALSE, fig.height=10, fig.width=12, message=FALSE, animation.hook="gifski", cache=F, interval=0.0125}
source("sodaphysics.R")
ff <- 0.137
kk <- 6.25
dt <-  0.001666667
ni <- 300

restlength <- VECTOR.len(subnet$n,subnet$e$from[1],subnet$e$to[1])

par(mfrow=c(2  ,2))

saveRDS(subnet,"tmp.RDS")
gn <- readRDS("tmp.RDS")

gn$n$fx <- 0
gn$n$fy <- 0
gn$n$vx <- 0
gn$n$vy <- 0
gn$n$ax <- 0
gn$n$ay <- 0
gn$e$fMag <- 0

saveRDS(gn,"tmp.RDS")
gn0<-readRDS("tmp.RDS")
gn1<-readRDS("tmp.RDS")
gn2<-readRDS("tmp.RDS")
gn3<-readRDS("tmp.RDS")
#gn2<-copy(gn)



tinc <-   60
ntimes <- 250

mm0<-0.1
mm1<-1.0
mm2<-10
mm3<-100


for(tt in 1:ntimes){
  rcupdateModel(gn0$n,gn$e,restlength,ff,kk,dt,tinc,mm0,1)
  rcupdateModel(gn1$n,gn$e,restlength,ff,kk,dt,tinc,mm1,1)
  rcupdateModel(gn2$n,gn$e,restlength,ff,kk,dt,tinc,mm2,1)
  rcupdateModel(gn3$n,gn$e,restlength,ff,kk,dt,tinc,mm3,1)
  
  plotnet(gn0,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn0)
  title(sprintf("tt = %d\nmm = %0.2f",tt,mm0))
  
  plotnet(gn1,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn1)
  title(sprintf("tt = %d\nmm = %0.2f",tt,mm1))
  
  plotnet(gn2,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn2)
  title(sprintf("tt = %d\nmm = %0.2f",tt,mm2))
  
  plotnet(gn3,xlim = range(net$n$x), ylim = c(-1,2))
  plotForces(gn3)
  title(sprintf("tt = %d\nmm = %0.2f",tt,mm3))
  
}
```

This is *just* what we need - increasing the mass increases the stiffness of the model - just like in "real" physics. This means we can look at ways to update the physical properties of the structure in response to the forces. Let's try an experiment with a couple of simple rules now: 












